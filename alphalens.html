

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Alphalens &mdash; Alphalens 0.2.1+48.gad0be10 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Alphalens 0.2.1+48.gad0be10 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Alphalens
          

          
          </a>

          
            
            
              <div class="version">
                0.2.1+48.gad0be10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Alphalens</a><ul>
<li><a class="reference internal" href="#module-alphalens.tears">Tear Sheets</a></li>
<li><a class="reference internal" href="#module-alphalens.performance">Performance</a></li>
<li><a class="reference internal" href="#module-alphalens.plotting">Plotting</a></li>
<li><a class="reference internal" href="#module-alphalens.utils">Utilities</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Alphalens</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Alphalens</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/alphalens.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="alphalens">
<h1>Alphalens<a class="headerlink" href="#alphalens" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-alphalens.tears">
<span id="tear-sheets"></span><h2>Tear Sheets<a class="headerlink" href="#module-alphalens.tears" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="alphalens.tears.GridFigure">
<em class="property">class </em><code class="descclassname">alphalens.tears.</code><code class="descname">GridFigure</code><span class="sig-paren">(</span><em>rows</em>, <em>cols</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.GridFigure" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>It makes life easier with grid plots</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="alphalens.tears.GridFigure.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.GridFigure.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="alphalens.tears.GridFigure.next_cell">
<code class="descname">next_cell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.GridFigure.next_cell" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="alphalens.tears.GridFigure.next_row">
<code class="descname">next_row</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.GridFigure.next_row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_event_returns_tear_sheet">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_event_returns_tear_sheet</code><span class="sig-paren">(</span><em>factor_data</em>, <em>prices</em>, <em>avgretplot=(5</em>, <em>15)</em>, <em>long_short=True</em>, <em>group_neutral=False</em>, <em>by_group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_event_returns_tear_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a tear sheet to view the average cumulative returns for a
factor within a window (pre and post event).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex Series indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, the factor
quantile/bin that factor value belongs to and (optionally) the group
the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>prices</strong> : pd.DataFrame</p>
<blockquote>
<div><p>A DataFrame indexed by date with assets in the columns containing the
pricing data.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>avgretplot: tuple (int, int) - (before, after)</strong></p>
<blockquote>
<div><p>If not None, plot quantile average cumulative returns</p>
</div></blockquote>
<p><strong>long_short</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a long short portfolio? if so then
factor returns will be demeaned across the factor universe</p>
</div></blockquote>
<p><strong>group_neutral</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a group neutral portfolio? if so,
returns demeaning will occur on the group level.</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote class="last">
<div><p>If True, display graphs separately for each group.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_event_returns_tear_sheet_api_change_warning">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_event_returns_tear_sheet_api_change_warning</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_event_returns_tear_sheet_api_change_warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator used to help API transition: maintain the function backward
compatible and warn the user about the API change.
Old API:</p>
<blockquote>
<div><dl class="docutils">
<dt>create_event_returns_tear_sheet(factor_data,</dt>
<dd>prices,
avgretplot=(5, 15),
long_short=True,
by_group=False)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>New API:</dt>
<dd><dl class="first last docutils">
<dt>create_event_returns_tear_sheet(factor_data,</dt>
<dd>prices,
avgretplot=(5, 15),
long_short=True,
group_neutral=False,
by_group=False)</dd>
</dl>
</dd>
</dl>
<p>Eventually this function can be deleted</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_event_study_tear_sheet">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_event_study_tear_sheet</code><span class="sig-paren">(</span><em>factor_data</em>, <em>prices=None</em>, <em>avgretplot=(5</em>, <em>15)</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_event_study_tear_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an event study tear sheet for analysis of a specific event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single event, forward returns for each
period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.</p>
</div></blockquote>
<p><strong>prices</strong> : pd.DataFrame, required only if ‘avgretplot’ is provided</p>
<blockquote>
<div><p>A DataFrame indexed by date with assets in the columns containing the
pricing data.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>avgretplot: tuple (int, int) - (before, after), optional</strong></p>
<blockquote class="last">
<div><p>If not None, plot event style average cumulative returns within a
window (pre and post event).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_full_tear_sheet">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_full_tear_sheet</code><span class="sig-paren">(</span><em>factor_data</em>, <em>long_short=True</em>, <em>group_neutral=False</em>, <em>by_group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_full_tear_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a full tear sheet for analysis and evaluating single
return predicting (alpha) factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>long_short</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a long short portfolio?
- See tears.create_returns_tear_sheet for details on how this flag
affects returns analysis</p>
</div></blockquote>
<p><strong>group_neutral</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a group neutral portfolio?
- See tears.create_returns_tear_sheet for details on how this flag
affects returns analysis
- See tears.create_information_tear_sheet for details on how this
flag affects information analysis</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote class="last">
<div><p>If True, display graphs separately for each group.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_full_tear_sheet_api_change_warning">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_full_tear_sheet_api_change_warning</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_full_tear_sheet_api_change_warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator used to help API transition: maintain the function backward
compatible and warn the user about the API change.
Old API:</p>
<blockquote>
<div><dl class="docutils">
<dt>create_full_tear_sheet(factor_data,</dt>
<dd>long_short=True,
group_adjust=False,
by_group=False)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>New API:</dt>
<dd><dl class="first last docutils">
<dt>create_full_tear_sheet(factor_data,</dt>
<dd>long_short=True,
group_neutral=False,
by_group=False)</dd>
</dl>
</dd>
</dl>
<p>Eventually this function can be deleted</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_information_tear_sheet">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_information_tear_sheet</code><span class="sig-paren">(</span><em>factor_data</em>, <em>group_neutral=False</em>, <em>by_group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_information_tear_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a tear sheet for information analysis of a factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>group_neutral</strong> : bool</p>
<blockquote>
<div><p>Demean forward returns by group before computing IC.</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote class="last">
<div><p>If True, display graphs separately for each group.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_information_tear_sheet_api_change_warning">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_information_tear_sheet_api_change_warning</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_information_tear_sheet_api_change_warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator used to help API transition: maintain the function backward
compatible and warn the user about the API change.
Old API:</p>
<blockquote>
<div><dl class="docutils">
<dt>create_information_tear_sheet(factor_data,</dt>
<dd>group_adjust=False,
by_group=False)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>New API:</dt>
<dd><dl class="first last docutils">
<dt>create_information_tear_sheet(factor_data,</dt>
<dd>group_neutral=False,
by_group=False)</dd>
</dl>
</dd>
</dl>
<p>Eventually this function can be deleted</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_returns_tear_sheet">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_returns_tear_sheet</code><span class="sig-paren">(</span><em>factor_data</em>, <em>long_short=True</em>, <em>group_neutral=False</em>, <em>by_group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_returns_tear_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a tear sheet for returns analysis of a factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to,
and (optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>long_short</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a long short portfolio? if so, then
mean quantile returns will be demeaned across the factor universe.
Additionally factor values will be demeaned across the factor universe
when factor weighting the portfolio for cumulative returns plots</p>
</div></blockquote>
<p><strong>group_neutral</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a group neutral portfolio? if so,
returns demeaning will occur on the group level.
Additionally each group will weight the same in cumulative returns
plots</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote class="last">
<div><p>If True, display graphs separately for each group.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_returns_tear_sheet_api_change_warning">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_returns_tear_sheet_api_change_warning</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_returns_tear_sheet_api_change_warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator used to help API transition: maintain the function backward
compatible and warn the user about the API change.
Old API:</p>
<blockquote>
<div><dl class="docutils">
<dt>create_returns_tear_sheet(factor_data,</dt>
<dd>long_short=True,
by_group=False)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>New API:</dt>
<dd><dl class="first last docutils">
<dt>create_returns_tear_sheet(factor_data,</dt>
<dd>long_short=True,
group_neutral=False,
by_group=False)</dd>
</dl>
</dd>
</dl>
<p>Eventually this function can be deleted</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_summary_tear_sheet">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_summary_tear_sheet</code><span class="sig-paren">(</span><em>factor_data</em>, <em>long_short=True</em>, <em>group_neutral=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_summary_tear_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a small summary tear sheet with returns, information, and turnover
analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>long_short</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a long short portfolio? if so, then
mean quantile returns will be demeaned across the factor universe.</p>
</div></blockquote>
<p><strong>group_neutral</strong> : bool</p>
<blockquote class="last">
<div><p>Should this computation happen on a group neutral portfolio? if so,
returns demeaning will occur on the group level.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.tears.create_turnover_tear_sheet">
<code class="descclassname">alphalens.tears.</code><code class="descname">create_turnover_tear_sheet</code><span class="sig-paren">(</span><em>factor_data</em>, <em>turnover_periods=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.tears.create_turnover_tear_sheet" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a tear sheet for analyzing the turnover properties of a factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>turnover_periods</strong> : sequence[string], optional</p>
<blockquote class="last">
<div><p>Periods to compute turnover analysis on. By default periods in
‘factor_data’ are used but custom periods can provided instead. This
can be useful when periods in ‘factor_data’ are not multiples of the
frequency at which factor values are computed i.e. the periods
are 2h and 4h and the factor is computed daily and so values like
[‘1D’, ‘2D’] could be used instead</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-alphalens.performance">
<span id="performance"></span><h2>Performance<a class="headerlink" href="#module-alphalens.performance" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="alphalens.performance.average_cumulative_return_by_quantile">
<code class="descclassname">alphalens.performance.</code><code class="descname">average_cumulative_return_by_quantile</code><span class="sig-paren">(</span><em>factor_data</em>, <em>prices</em>, <em>periods_before=10</em>, <em>periods_after=15</em>, <em>demeaned=True</em>, <em>group_adjust=False</em>, <em>by_group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.average_cumulative_return_by_quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots average cumulative returns by factor quantiles in the period range
defined by -periods_before to periods_after</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>prices</strong> : pd.DataFrame</p>
<blockquote>
<div><p>A wide form Pandas DataFrame indexed by date with assets
in the columns. Pricing data should span the factor
analysis time period plus/minus an additional buffer window
corresponding to periods_after/periods_before parameters.</p>
</div></blockquote>
<p><strong>periods_before</strong> : int, optional</p>
<blockquote>
<div><p>How many periods before factor to plot</p>
</div></blockquote>
<p><strong>periods_after</strong> : int, optional</p>
<blockquote>
<div><p>How many periods after factor to plot</p>
</div></blockquote>
<p><strong>demeaned</strong> : bool, optional</p>
<blockquote>
<div><p>Compute demeaned mean returns (long short portfolio)</p>
</div></blockquote>
<p><strong>group_adjust</strong> : bool</p>
<blockquote>
<div><p>Returns demeaning will occur on the group level (group
neutral portfolio)</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote>
<div><p>If True, compute cumulative returns separately for each group</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>——-</strong></p>
<p><strong>cumulative returns and std deviation</strong> : pd.DataFrame</p>
<blockquote class="last">
<div><p>A MultiIndex DataFrame indexed by quantile (level 0) and mean/std
(level 1) and the values on the columns in range from
-periods_before to periods_after
If by_group=True the index will have an additional ‘group’ level</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">---------------------------------------------------</span>
            <span class="o">|</span>       <span class="o">|</span> <span class="o">-</span><span class="mi">2</span>  <span class="o">|</span> <span class="o">-</span><span class="mi">1</span>  <span class="o">|</span>  <span class="mi">0</span>  <span class="o">|</span>  <span class="mi">1</span>  <span class="o">|</span> <span class="o">...</span>
<span class="o">---------------------------------------------------</span>
  <span class="n">quantile</span>  <span class="o">|</span>       <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>
<span class="o">---------------------------------------------------</span>
            <span class="o">|</span> <span class="n">mean</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>
     <span class="mi">1</span>      <span class="o">---------------------------------------</span>
            <span class="o">|</span> <span class="n">std</span>   <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>
<span class="o">---------------------------------------------------</span>
            <span class="o">|</span> <span class="n">mean</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>
     <span class="mi">2</span>      <span class="o">---------------------------------------</span>
            <span class="o">|</span> <span class="n">std</span>   <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>  <span class="n">x</span>  <span class="o">|</span>
<span class="o">---------------------------------------------------</span>
    <span class="o">...</span>     <span class="o">|</span>                 <span class="o">...</span>
<span class="o">---------------------------------------------------</span>
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.common_start_returns">
<code class="descclassname">alphalens.performance.</code><code class="descname">common_start_returns</code><span class="sig-paren">(</span><em>factor</em>, <em>prices</em>, <em>before</em>, <em>after</em>, <em>cumulative=False</em>, <em>mean_by_date=False</em>, <em>demean_by=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.common_start_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>A date and equity pair is extracted from each index row in the factor
dataframe and for each of these pairs a return series is built starting
from ‘before’ the date and ending ‘after’ the date specified in the pair.
All those returns series are then aligned to a common index (-before to
after) and returned as a single DataFrame</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : pd.DataFrame</p>
<blockquote>
<div><p>DataFrame with at least date and equity as index, the columns are
irrelevant</p>
</div></blockquote>
<p><strong>prices</strong> : pd.DataFrame</p>
<blockquote>
<div><p>A wide form Pandas DataFrame indexed by date with assets
in the columns. Pricing data should span the factor
analysis time period plus/minus an additional buffer window
corresponding to after/before period parameters.</p>
</div></blockquote>
<p><strong>before:</strong></p>
<blockquote>
<div><p>How many returns to load before factor date</p>
</div></blockquote>
<p><strong>after:</strong></p>
<blockquote>
<div><p>How many returns to load after factor date</p>
</div></blockquote>
<p><strong>cumulative: bool, optional</strong></p>
<blockquote>
<div><p>Return cumulative returns</p>
</div></blockquote>
<p><strong>mean_by_date: bool, optional</strong></p>
<blockquote>
<div><p>If True, compute mean returns for each date and return that
instead of a return series for each asset</p>
</div></blockquote>
<p><strong>demean_by: pd.DataFrame, optional</strong></p>
<blockquote>
<div><p>DataFrame with at least date and equity as index, the columns are
irrelevant. For each date a list of equities is extracted from
‘demean_by’ index and used as universe to compute demeaned mean
returns (long short portfolio)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aligned_returns</strong> : pd.DataFrame</p>
<blockquote class="last">
<div><p>Dataframe containing returns series for each factor aligned to the same
index: -before to after</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.compute_mean_returns_spread">
<code class="descclassname">alphalens.performance.</code><code class="descname">compute_mean_returns_spread</code><span class="sig-paren">(</span><em>mean_returns</em>, <em>upper_quant</em>, <em>lower_quant</em>, <em>std_err=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.compute_mean_returns_spread" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the difference between the mean returns of
two quantiles. Optionally, computes the standard error
of this difference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mean_returns</strong> : pd.DataFrame</p>
<blockquote>
<div><p>DataFrame of mean period wise returns by quantile.
MultiIndex containing date and quantile.
See mean_return_by_quantile.</p>
</div></blockquote>
<p><strong>upper_quant</strong> : int</p>
<blockquote>
<div><p>Quantile of mean return from which we
wish to subtract lower quantile mean return.</p>
</div></blockquote>
<p><strong>lower_quant</strong> : int</p>
<blockquote>
<div><p>Quantile of mean return we wish to subtract
from upper quantile mean return.</p>
</div></blockquote>
<p><strong>std_err</strong> : pd.DataFrame</p>
<blockquote>
<div><p>Period wise standard error in mean return by quantile.
Takes the same form as mean_returns.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mean_return_difference</strong> : pd.Series</p>
<blockquote>
<div><p>Period wise difference in quantile returns.</p>
</div></blockquote>
<p><strong>joint_std_err</strong> : pd.Series</p>
<blockquote class="last">
<div><p>Period wise standard error of the difference in quantile returns.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.create_pyfolio_input">
<code class="descclassname">alphalens.performance.</code><code class="descname">create_pyfolio_input</code><span class="sig-paren">(</span><em>factor_data</em>, <em>period</em>, <em>long_short=True</em>, <em>group_neutral=False</em>, <em>quantiles=None</em>, <em>groups=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.create_pyfolio_input" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>WARNING: this API is still in experimental phase and input/output</dt>
<dd>paramenters might change in the future</dd>
</dl>
<p>Simulate a portfolio using the factor in input and returns a DataFrames
containing the portfolio returns formatted for pyfolio.</p>
<p>For more details on how this portfolio is built see:
- performance.factor_returns (how assets weights are computed)
- performance.cumulative_returns (how the portfolio returns are computed)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to,
and (optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>period</strong> : string</p>
<blockquote>
<div><p>‘factor_data’ column name corresponding to the ‘period’ returns to be
used in the computation of porfolio returns</p>
</div></blockquote>
<p><strong>long_short</strong> : bool, optional</p>
<blockquote>
<div><p>Should this computation happen on a long short portfolio? if so, then
factor values will be demeaned across the factor universe when factor
weighting the portfolio for cumulative returns plots</p>
</div></blockquote>
<p><strong>group_neutral</strong> : bool, optional</p>
<blockquote>
<div><p>Should this computation happen on a group neutral portfolio? if so,
factor values demeaning will occur on the group level.
Additionally each group will weight the same in cumulative returns
plots</p>
</div></blockquote>
<p><strong>quantiles: sequence[int], optional</strong></p>
<blockquote>
<div><p>Use only specific quantiles in the computation. By default all
quantiles are used</p>
</div></blockquote>
<p><strong>groups: sequence[string], optional</strong></p>
<blockquote>
<div><p>Use only specific groups in the computation. By default all groups
are used</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>returns</strong> : pd.Series</p>
<blockquote class="last">
<div><blockquote>
<div><p>Daily returns of the strategy, noncumulative.</p>
</div></blockquote>
<dl class="docutils">
<dt>benchmark <span class="classifier-delimiter">:</span> <span class="classifier">pd.Series</span></dt>
<dd><p class="first last">Benchmark returns computed as the factor universe mean daily returns.
If ‘1D’ period column is not present in the factor_data the beanchmark
returns is not computed and returned as ‘None’</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.cumulative_returns">
<code class="descclassname">alphalens.performance.</code><code class="descname">cumulative_returns</code><span class="sig-paren">(</span><em>returns</em>, <em>period</em>, <em>freq=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.cumulative_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds cumulative returns from ‘period’ returns. This function simulate the
cumulative effect that a series of gains or losses (the ‘retuns’) have on
an original amount of capital over a period of time.</p>
<p>if F is the frequency at which returns are computed (e.g. 1 day if
‘returns’ contains daily values) and N is the period for which the retuns
are computed (e.g. returns after 1 day, 5 hours or 3 days) then:
- if N &lt;= F the cumulative retuns are trivially computed as Compound Return
- if N &gt; F (e.g. F 1 day, and N is 3 days) then the returns overlap and the</p>
<blockquote>
<div>cumulative returns are computed building and averaging N interleaved sub
portfolios (started at subsequent periods 1,2,..,N) each one rebalancing
every N periods. This correspond to an algorithm which trades the factor
every single time it is computed, which is statistically more robust and
with a lower volatity compared to an algorithm that trades the factor
every N periods and whose returns depend on the specific starting day of
trading.</div></blockquote>
<p>Also note that when the factor is not computed at a specific frequency, for
exaple a factor representing a random event, it is not efficient to create
multiples sub-portfolios as it is not certain when the factor will be
traded and this would result in an underleveraged portfolio. In this case
the simulated portfolio is fully invested whenever an event happens and if
a subsequent event occur while the portfolio is still invested in a
previous event then the portfolio is rebalanced and split equally among the
active events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>returns: pd.Series</strong></p>
<blockquote>
<div><p>pd.Series containing factor ‘period’ forward returns, the index
contains timestamps at which the trades are computed and the values
correspond to returns after ‘period’ time</p>
</div></blockquote>
<p><strong>period: pandas.Timedelta or string</strong></p>
<blockquote>
<div><p>Length of period for which the returns are computed (1 day, 2 mins,
3 hours etc). It can be a Timedelta or a string in the format accepted
by Timedelta constructor (‘1 days’, ‘1D’, ‘30m’, ‘3h’, ‘1D1h’, etc)</p>
</div></blockquote>
<p><strong>freq</strong> : pandas DateOffset, optional</p>
<blockquote>
<div><p>Used to specify a particular trading calendar. If not present
returns.index.freq will be used</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pd.Series</p>
<blockquote class="last">
<div><p>Cumulative returns series</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.factor_alpha_beta">
<code class="descclassname">alphalens.performance.</code><code class="descname">factor_alpha_beta</code><span class="sig-paren">(</span><em>factor_data</em>, <em>returns=None</em>, <em>demeaned=True</em>, <em>group_adjust=False</em>, <em>equal_weight=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.factor_alpha_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the alpha (excess returns), alpha t-stat (alpha significance),
and beta (market exposure) of a factor. A regression is run with
the period wise factor universe mean return as the independent variable
and mean period wise return from a portfolio weighted by factor values
as the dependent variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>returns</strong> : pd.DataFrame, optional</p>
<blockquote>
<div><p>Period wise factor returns. If this is None then it will be computed
with ‘factor_returns’ function and the passed flags: ‘demeaned’,
‘group_adjust’, ‘equal_weight’</p>
</div></blockquote>
<p><strong>demeaned</strong> : bool</p>
<blockquote>
<div><p>Control how to build factor returns used for alpha/beta computation
– see performance.factor_return for a full explanation</p>
</div></blockquote>
<p><strong>group_adjust</strong> : bool</p>
<blockquote>
<div><p>Control how to build factor returns used for alpha/beta computation
– see performance.factor_return for a full explanation</p>
</div></blockquote>
<p><strong>equal_weight</strong> : bool, optional</p>
<blockquote>
<div><p>Control how to build factor returns used for alpha/beta computation
– see performance.factor_return for a full explanation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alpha_beta</strong> : pd.Series</p>
<blockquote class="last">
<div><p>A list containing the alpha, beta, a t-stat(alpha)
for the given factor and forward returns.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.factor_information_coefficient">
<code class="descclassname">alphalens.performance.</code><code class="descname">factor_information_coefficient</code><span class="sig-paren">(</span><em>factor_data</em>, <em>group_adjust=False</em>, <em>by_group=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.factor_information_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Spearman Rank Correlation based Information Coefficient (IC)
between factor values and N period forward returns for each period in
the factor index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>group_adjust</strong> : bool</p>
<blockquote>
<div><p>Demean forward returns by group before computing IC.</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote>
<div><p>If True, compute period wise IC separately for each group.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ic</strong> : pd.DataFrame</p>
<blockquote class="last">
<div><p>Spearman Rank correlation between factor and
provided forward returns.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.factor_rank_autocorrelation">
<code class="descclassname">alphalens.performance.</code><code class="descname">factor_rank_autocorrelation</code><span class="sig-paren">(</span><em>factor_data</em>, <em>period=1</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.factor_rank_autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes autocorrelation of mean factor ranks in specified time spans.
We must compare period to period factor ranks rather than factor values
to account for systematic shifts in the factor values of all names or names
within a group. This metric is useful for measuring the turnover of a
factor. If the value of a factor for each name changes randomly from period
to period, we’d expect an autocorrelation of 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>period: string or int, optional</strong></p>
<blockquote>
<div><p>Period over which to calculate the turnover. If it is a string it must
follow pandas.Timedelta constructor format (e.g. ‘1 days’, ‘1D’, ‘30m’,
‘3h’, ‘1D1h’, etc).</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>——-</strong></p>
<p><strong>autocorr</strong> : pd.Series</p>
<blockquote class="last">
<div><p>Rolling 1 period (defined by time_rule) autocorrelation of
factor values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.factor_returns">
<code class="descclassname">alphalens.performance.</code><code class="descname">factor_returns</code><span class="sig-paren">(</span><em>factor_data</em>, <em>demeaned=True</em>, <em>group_adjust=False</em>, <em>equal_weight=False</em>, <em>by_asset=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.factor_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes period wise returns for portfolio weighted by factor
values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>demeaned</strong> : bool</p>
<blockquote>
<div><p>Control how to build factor weights
– see performance.factor_weights for a full explanation</p>
</div></blockquote>
<p><strong>group_adjust</strong> : bool</p>
<blockquote>
<div><p>Control how to build factor weights
– see performance.factor_weights for a full explanation</p>
</div></blockquote>
<p><strong>equal_weight</strong> : bool, optional</p>
<blockquote>
<div><p>Control how to build factor weights
– see performance.factor_weights for a full explanation</p>
</div></blockquote>
<p><strong>by_asset: bool, optional</strong></p>
<blockquote>
<div><p>If True, returns are reported separately for each esset.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>returns</strong> : pd.DataFrame</p>
<blockquote class="last">
<div><p>Period wise factor returns</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.factor_weights">
<code class="descclassname">alphalens.performance.</code><code class="descname">factor_weights</code><span class="sig-paren">(</span><em>factor_data</em>, <em>demeaned=True</em>, <em>group_adjust=False</em>, <em>equal_weight=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.factor_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes asset weights by factor values and dividing by the sum of their
absolute value (achieving gross leverage of 1). Positive factor values will
results in positive weights and negative values in negative weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>demeaned</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a long short portfolio? if True,
weights are computed by demeaning factor values and dividing by the sum
of their absolute value (achieving gross leverage of 1). The sum of
positive weights will be the same as the negative weights (absolute
value), suitable for a dollar neutral long-short portfolio</p>
</div></blockquote>
<p><strong>group_adjust</strong> : bool</p>
<blockquote>
<div><p>Should this computation happen on a group neutral portfolio? If True,
compute group neutral weights: each group will weight the same and
if ‘demeaned’ is enabled the factor values demeaning will occur on the
group level.</p>
</div></blockquote>
<p><strong>equal_weight</strong> : bool, optional</p>
<blockquote>
<div><p>if True the assets will be equal-weighted instead of factor-weighted</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>returns</strong> : pd.Series</p>
<blockquote class="last">
<div><p>Assets weighted by factor value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.mean_information_coefficient">
<code class="descclassname">alphalens.performance.</code><code class="descname">mean_information_coefficient</code><span class="sig-paren">(</span><em>factor_data</em>, <em>group_adjust=False</em>, <em>by_group=False</em>, <em>by_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.mean_information_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mean information coefficient of specified groups.
Answers questions like:
What is the mean IC for each month?
What is the mean IC for each group for our whole timerange?
What is the mean IC for for each group, each week?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>group_adjust</strong> : bool</p>
<blockquote>
<div><p>Demean forward returns by group before computing IC.</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote>
<div><p>If True, take the mean IC for each group.</p>
</div></blockquote>
<p><strong>by_time</strong> : str (pd time_rule), optional</p>
<blockquote>
<div><p>Time window to use when taking mean IC.
See <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html">http://pandas.pydata.org/pandas-docs/stable/timeseries.html</a>
for available options.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ic</strong> : pd.DataFrame</p>
<blockquote class="last">
<div><p>Mean Spearman Rank correlation between factor and provided
forward price movement windows.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.mean_return_by_quantile">
<code class="descclassname">alphalens.performance.</code><code class="descname">mean_return_by_quantile</code><span class="sig-paren">(</span><em>factor_data</em>, <em>by_date=False</em>, <em>by_group=False</em>, <em>demeaned=True</em>, <em>group_adjust=False</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.mean_return_by_quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes mean returns for factor quantiles across
provided forward returns columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- See full explanation in utils.get_clean_factor_and_forward_returns</p>
</div></blockquote>
<p><strong>by_date</strong> : bool</p>
<blockquote>
<div><p>If True, compute quantile bucket returns separately for each date.</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote>
<div><p>If True, compute quantile bucket returns separately for each group.</p>
</div></blockquote>
<p><strong>demeaned</strong> : bool</p>
<blockquote>
<div><p>Compute demeaned mean returns (long short portfolio)</p>
</div></blockquote>
<p><strong>group_adjust</strong> : bool</p>
<blockquote>
<div><p>Returns demeaning will occur on the group level.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mean_ret</strong> : pd.DataFrame</p>
<blockquote>
<div><p>Mean period wise returns by specified factor quantile.</p>
</div></blockquote>
<p><strong>std_error_ret</strong> : pd.DataFrame</p>
<blockquote class="last">
<div><p>Standard error of returns by specified quantile.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.performance.quantile_turnover">
<code class="descclassname">alphalens.performance.</code><code class="descname">quantile_turnover</code><span class="sig-paren">(</span><em>quantile_factor</em>, <em>quantile</em>, <em>period=1</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.performance.quantile_turnover" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the proportion of names in a factor quantile that were
not in that quantile in the previous period.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quantile_factor</strong> : pd.Series</p>
<blockquote>
<div><p>DataFrame with date, asset and factor quantile.</p>
</div></blockquote>
<p><strong>quantile</strong> : int</p>
<blockquote>
<div><p>Quantile on which to perform turnover analysis.</p>
</div></blockquote>
<p><strong>period: string or int, optional</strong></p>
<blockquote>
<div><p>Period over which to calculate the turnover. If it is a string it must
follow pandas.Timedelta constructor format (e.g. ‘1 days’, ‘1D’, ‘30m’,
‘3h’, ‘1D1h’, etc).</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>——-</strong></p>
<p><strong>quant_turnover</strong> : pd.Series</p>
<blockquote class="last">
<div><p>Period by period turnover for that quantile.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-alphalens.plotting">
<span id="plotting"></span><h2>Plotting<a class="headerlink" href="#module-alphalens.plotting" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="alphalens.plotting.axes_style">
<code class="descclassname">alphalens.plotting.</code><code class="descname">axes_style</code><span class="sig-paren">(</span><em>style='darkgrid'</em>, <em>rc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.axes_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Create alphalens default axes style context.</p>
<p>Under the hood, calls and returns seaborn.axes_style() with
some custom settings. Usually you would use in a with-context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>style</strong> : str, optional</p>
<blockquote>
<div><p>Name of seaborn style.</p>
</div></blockquote>
<p><strong>rc</strong> : dict, optional</p>
<blockquote>
<div><p>Config flags.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">seaborn plotting context</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">For</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">see</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.customize">
<code class="descclassname">alphalens.plotting.</code><code class="descname">customize</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.customize" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to set plotting context and axes style during function call.</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_cumulative_returns">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_cumulative_returns</code><span class="sig-paren">(</span><em>factor_returns</em>, <em>period</em>, <em>title=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_cumulative_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the cumulative returns of the returns series passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_returns</strong> : pd.Series</p>
<blockquote>
<div><p>Period wise returns of dollar neutral portfolio weighted by factor
value.</p>
</div></blockquote>
<p><strong>period: pandas.Timedelta or string</strong></p>
<blockquote>
<div><p>Length of period for which the returns are computed (e.g. 1 day)
if ‘period’ is a string it must follow pandas.Timedelta constructor
format (e.g. ‘1 days’, ‘1D’, ‘30m’, ‘3h’, ‘1D1h’, etc)</p>
</div></blockquote>
<p><strong>title: string, optional</strong></p>
<blockquote>
<div><p>Custom title</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_cumulative_returns_by_quantile">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_cumulative_returns_by_quantile</code><span class="sig-paren">(</span><em>quantile_returns</em>, <em>period</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_cumulative_returns_by_quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the cumulative returns of various factor quantiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quantile_returns</strong> : pd.DataFrame</p>
<blockquote>
<div><p>Returns by factor quantile</p>
</div></blockquote>
<p><strong>period: pandas.Timedelta or string</strong></p>
<blockquote>
<div><p>Length of period for which the returns are computed (e.g. 1 day)
if ‘period’ is a string it must follow pandas.Timedelta constructor
format (e.g. ‘1 days’, ‘1D’, ‘30m’, ‘3h’, ‘1D1h’, etc)</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ax</strong> : matplotlib.Axes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_events_distribution">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_events_distribution</code><span class="sig-paren">(</span><em>events</em>, <em>num_bars=50</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_events_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the distribution of events in time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : pd.Series</p>
<blockquote>
<div><p>A pd.Series whose index contains at least ‘date’ level.</p>
</div></blockquote>
<p><strong>num_bars</strong> : integer, optional</p>
<blockquote>
<div><p>Number of bars to plot</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ax</strong> : matplotlib.Axes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_factor_rank_auto_correlation">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_factor_rank_auto_correlation</code><span class="sig-paren">(</span><em>factor_autocorrelation</em>, <em>period=1</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_factor_rank_auto_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots factor rank autocorrelation over time.
See factor_rank_autocorrelation for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_autocorrelation</strong> : pd.Series</p>
<blockquote>
<div><p>Rolling 1 period (defined by time_rule) autocorrelation
of factor values.</p>
</div></blockquote>
<p><strong>period: int, optional</strong></p>
<blockquote>
<div><p>Period over which the autocorrelation is calculated</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_ic_by_group">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_ic_by_group</code><span class="sig-paren">(</span><em>ic_group</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_ic_by_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots Spearman Rank Information Coefficient for a given factor over
provided forward returns. Separates by group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ic_group</strong> : pd.DataFrame</p>
<blockquote>
<div><p>group-wise mean period wise returns.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_ic_hist">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_ic_hist</code><span class="sig-paren">(</span><em>ic</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_ic_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots Spearman Rank Information Coefficient histogram for a given factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ic</strong> : pd.DataFrame</p>
<blockquote>
<div><p>DataFrame indexed by date, with IC for each forward return.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_ic_qq">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_ic_qq</code><span class="sig-paren">(</span><em>ic</em>, <em>theoretical_dist=&lt;scipy.stats._continuous_distns.norm_gen object&gt;</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_ic_qq" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots Spearman Rank Information Coefficient “Q-Q” plot relative to
a theoretical distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ic</strong> : pd.DataFrame</p>
<blockquote>
<div><p>DataFrame indexed by date, with IC for each forward return.</p>
</div></blockquote>
<p><strong>theoretical_dist</strong> : scipy.stats._continuous_distns</p>
<blockquote>
<div><p>Continuous distribution generator. scipy.stats.norm and
scipy.stats.t are popular options.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_ic_ts">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_ic_ts</code><span class="sig-paren">(</span><em>ic</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_ic_ts" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots Spearman Rank Information Coefficient and IC moving
average for a given factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ic</strong> : pd.DataFrame</p>
<blockquote>
<div><p>DataFrame indexed by date, with IC for each forward return.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_information_table">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_information_table</code><span class="sig-paren">(</span><em>ic_data</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_information_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_mean_quantile_returns_spread_time_series">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_mean_quantile_returns_spread_time_series</code><span class="sig-paren">(</span><em>mean_returns_spread</em>, <em>std_err=None</em>, <em>bandwidth=1</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_mean_quantile_returns_spread_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots mean period wise returns for factor quantiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mean_returns_spread</strong> : pd.Series</p>
<blockquote>
<div><p>Series with difference between quantile mean returns by period.</p>
</div></blockquote>
<p><strong>std_err</strong> : pd.Series</p>
<blockquote>
<div><p>Series with standard error of difference between quantile
mean returns each period.</p>
</div></blockquote>
<p><strong>bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of displayed error bands in standard deviations.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_monthly_ic_heatmap">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_monthly_ic_heatmap</code><span class="sig-paren">(</span><em>mean_monthly_ic</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_monthly_ic_heatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a heatmap of the information coefficient or returns by month.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mean_monthly_ic</strong> : pd.DataFrame</p>
<blockquote>
<div><p>The mean monthly IC for N periods forward.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_quantile_average_cumulative_return">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_quantile_average_cumulative_return</code><span class="sig-paren">(</span><em>avg_cumulative_returns</em>, <em>by_quantile=False</em>, <em>std_bar=False</em>, <em>title=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_quantile_average_cumulative_return" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots sector-wise mean daily returns for factor quantiles
across provided forward price movement columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>avg_cumulative_returns: pd.Dataframe</strong></p>
<blockquote>
<div><p>The format is the one returned by
performance.average_cumulative_return_by_quantile</p>
</div></blockquote>
<p><strong>by_quantile</strong> : boolean, optional</p>
<blockquote>
<div><p>Disaggregated figures by quantile (useful to clearly see std dev bars)</p>
</div></blockquote>
<p><strong>std_bar</strong> : boolean, optional</p>
<blockquote>
<div><p>Plot standard deviation plot</p>
</div></blockquote>
<p><strong>title: string, optional</strong></p>
<blockquote>
<div><p>Custom title</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ax</strong> : matplotlib.Axes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_quantile_returns_bar">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_quantile_returns_bar</code><span class="sig-paren">(</span><em>mean_ret_by_q</em>, <em>by_group=False</em>, <em>ylim_percentiles=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_quantile_returns_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots mean period wise returns for factor quantiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mean_ret_by_q</strong> : pd.DataFrame</p>
<blockquote>
<div><p>DataFrame with quantile, (group) and mean period wise return values.</p>
</div></blockquote>
<p><strong>by_group</strong> : bool</p>
<blockquote>
<div><p>Disaggregated figures by group.</p>
</div></blockquote>
<p><strong>ylim_percentiles</strong> : tuple of integers</p>
<blockquote>
<div><p>Percentiles of observed data to use as y limits for plot.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_quantile_returns_violin">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_quantile_returns_violin</code><span class="sig-paren">(</span><em>return_by_q</em>, <em>ylim_percentiles=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_quantile_returns_violin" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a violin box plot of period wise returns for factor quantiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>return_by_q</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>DataFrame with date and quantile as rows MultiIndex,
forward return windows as columns, returns as values.</p>
</div></blockquote>
<p><strong>ylim_percentiles</strong> : tuple of integers</p>
<blockquote>
<div><p>Percentiles of observed data to use as y limits for plot.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_quantile_statistics_table">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_quantile_statistics_table</code><span class="sig-paren">(</span><em>factor_data</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_quantile_statistics_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_returns_table">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_returns_table</code><span class="sig-paren">(</span><em>alpha_beta</em>, <em>mean_ret_quantile</em>, <em>mean_ret_spread_quantile</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_returns_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_top_bottom_quantile_turnover">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_top_bottom_quantile_turnover</code><span class="sig-paren">(</span><em>quantile_turnover</em>, <em>period=1</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_top_bottom_quantile_turnover" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots period wise top and bottom quantile factor turnover.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quantile_turnover: pd.Dataframe</strong></p>
<blockquote>
<div><p>Quantile turnover (each DataFrame column a quantile).</p>
</div></blockquote>
<p><strong>period: int, optional</strong></p>
<blockquote>
<div><p>Period over which to calculate the turnover</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.Axes, optional</p>
<blockquote>
<div><p>Axes upon which to plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.Axes</p>
<blockquote class="last">
<div><p>The axes that were plotted on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plot_turnover_table">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plot_turnover_table</code><span class="sig-paren">(</span><em>autocorrelation_data</em>, <em>quantile_turnover</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plot_turnover_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="alphalens.plotting.plotting_context">
<code class="descclassname">alphalens.plotting.</code><code class="descname">plotting_context</code><span class="sig-paren">(</span><em>context='notebook'</em>, <em>font_scale=1.5</em>, <em>rc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.plotting.plotting_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Create alphalens default plotting style context.</p>
<p>Under the hood, calls and returns seaborn.plotting_context() with
some custom settings. Usually you would use in a with-context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>context</strong> : str, optional</p>
<blockquote>
<div><p>Name of seaborn context.</p>
</div></blockquote>
<p><strong>font_scale</strong> : float, optional</p>
<blockquote>
<div><p>Scale font by factor font_scale.</p>
</div></blockquote>
<p><strong>rc</strong> : dict, optional</p>
<blockquote>
<div><p>Config flags.
By default, {‘lines.linewidth’: 1.5}
is being used and will be added to any
rc passed in, unless explicitly overriden.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">seaborn plotting context</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">For</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">see</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-alphalens.utils">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-alphalens.utils" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="alphalens.utils.MaxLossExceededError">
<em class="property">exception </em><code class="descclassname">alphalens.utils.</code><code class="descname">MaxLossExceededError</code><a class="headerlink" href="#alphalens.utils.MaxLossExceededError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="exception">
<dt id="alphalens.utils.NonMatchingTimezoneError">
<em class="property">exception </em><code class="descclassname">alphalens.utils.</code><code class="descname">NonMatchingTimezoneError</code><a class="headerlink" href="#alphalens.utils.NonMatchingTimezoneError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.add_custom_calendar_timedelta">
<code class="descclassname">alphalens.utils.</code><code class="descname">add_custom_calendar_timedelta</code><span class="sig-paren">(</span><em>input</em>, <em>timedelta</em>, <em>freq</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.add_custom_calendar_timedelta" title="Permalink to this definition">¶</a></dt>
<dd><p>Add timedelta to ‘input’ taking into consideration custom frequency, which
is used to deal with custom calendars, such as a trading calendar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : pd.DatetimeIndex or pd.Timestamp</p>
<p><strong>timedelta</strong> : pd.Timedelta</p>
<p><strong>freq</strong> : DateOffset, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pd.DatetimeIndex or pd.Timestamp</p>
<blockquote class="last">
<div><p>input + timedelta</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.compute_forward_returns">
<code class="descclassname">alphalens.utils.</code><code class="descname">compute_forward_returns</code><span class="sig-paren">(</span><em>factor_idx</em>, <em>prices</em>, <em>periods=(1</em>, <em>5</em>, <em>10)</em>, <em>filter_zscore=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.compute_forward_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the N period forward returns (as percent change) for each asset
provided.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_idx</strong> : pd.DatetimeIndex</p>
<blockquote>
<div><p>The factor datetimes for which we are computing the forward returns</p>
</div></blockquote>
<p><strong>prices</strong> : pd.DataFrame</p>
<blockquote>
<div><p>Pricing data to use in forward price calculation.
Assets as columns, dates as index. Pricing data must
span the factor analysis time period plus an additional buffer window
that is greater than the maximum number of expected periods
in the forward returns calculations.</p>
</div></blockquote>
<p><strong>periods</strong> : sequence[int]</p>
<blockquote>
<div><p>periods to compute forward returns on.</p>
</div></blockquote>
<p><strong>filter_zscore</strong> : int or float, optional</p>
<blockquote>
<div><p>Sets forward returns greater than X standard deviations
from the the mean to nan. Set it to ‘None’ to avoid filtering.
Caution: this outlier filtering incorporates lookahead bias.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>forward_returns</strong> : pd.DataFrame - MultiIndex</p>
<blockquote class="last">
<div><p>Forward returns in indexed by date and asset.
Separate column for each forward return window.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.demean_forward_returns">
<code class="descclassname">alphalens.utils.</code><code class="descname">demean_forward_returns</code><span class="sig-paren">(</span><em>factor_data</em>, <em>grouper=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.demean_forward_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert forward returns to returns relative to mean
period wise all-universe or group returns.
group-wise normalization incorporates the assumption of a
group neutral portfolio constraint and thus allows allows the
factor to be evaluated across groups.</p>
<p>For example, if AAPL 5 period return is 0.1% and mean 5 period
return for the Technology stocks in our universe was 0.5% in the
same period, the group adjusted 5 period return for AAPL in this
period is -0.4%.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote>
<div><p>Forward returns in indexed by date and asset.
Separate column for each forward return window.</p>
</div></blockquote>
<p><strong>grouper</strong> : list</p>
<blockquote>
<div><p>If True, demean according to group.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>adjusted_forward_returns</strong> : pd.DataFrame - MultiIndex</p>
<blockquote class="last">
<div><p>DataFrame of the same format as the input, but with each
security’s returns normalized by group.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.diff_custom_calendar_timedeltas">
<code class="descclassname">alphalens.utils.</code><code class="descname">diff_custom_calendar_timedeltas</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>freq</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.diff_custom_calendar_timedeltas" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the difference between two pd.Timedelta taking into consideration
custom frequency, which is used to deal with custom calendars, such as a
trading calendar</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : pd.Timestamp</p>
<p><strong>end</strong> : pd.Timestamp</p>
<p><strong>freq</strong> : DateOffset, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pd.Timedelta</p>
<blockquote class="last">
<div><p>end - start</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.get_clean_factor_and_forward_returns">
<code class="descclassname">alphalens.utils.</code><code class="descname">get_clean_factor_and_forward_returns</code><span class="sig-paren">(</span><em>factor</em>, <em>prices</em>, <em>groupby=None</em>, <em>binning_by_group=False</em>, <em>quantiles=5</em>, <em>bins=None</em>, <em>periods=(1</em>, <em>5</em>, <em>10)</em>, <em>filter_zscore=20</em>, <em>groupby_labels=None</em>, <em>max_loss=0.35</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.get_clean_factor_and_forward_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats the factor data, pricing data, and group mappings into a DataFrame
that contains aligned MultiIndex indices of timestamp and asset. The
returned data will be formatted to be suitable for Alphalens functions.</p>
<p>It is safe to skip a call to this function and still make use of Alphalens
functionalities as long as the factor data conforms to the format returned
from get_clean_factor_and_forward_returns and documented here</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> : pd.Series - MultiIndex</p>
<blockquote>
<div><p>A MultiIndex Series indexed by timestamp (level 0) and asset
(level 1), containing the values for a single alpha factor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-----------------------------------</span>
    <span class="n">date</span>    <span class="o">|</span>    <span class="n">asset</span>   <span class="o">|</span>
<span class="o">-----------------------------------</span>
            <span class="o">|</span>   <span class="n">AAPL</span>     <span class="o">|</span>   <span class="mf">0.5</span>
            <span class="o">-----------------------</span>
            <span class="o">|</span>   <span class="n">BA</span>       <span class="o">|</span>  <span class="o">-</span><span class="mf">1.1</span>
            <span class="o">-----------------------</span>
<span class="mi">2014</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">01</span>  <span class="o">|</span>   <span class="n">CMG</span>      <span class="o">|</span>   <span class="mf">1.7</span>
            <span class="o">-----------------------</span>
            <span class="o">|</span>   <span class="n">DAL</span>      <span class="o">|</span>  <span class="o">-</span><span class="mf">0.1</span>
            <span class="o">-----------------------</span>
            <span class="o">|</span>   <span class="n">LULU</span>     <span class="o">|</span>   <span class="mf">2.7</span>
            <span class="o">-----------------------</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>prices</strong> : pd.DataFrame</p>
<blockquote>
<div><p>A wide form Pandas DataFrame indexed by timestamp with assets
in the columns. It is important to pass the
correct pricing data in depending on what time of period your
signal was generated so to avoid lookahead bias, or
delayed calculations. Pricing data must span the factor
analysis time period plus an additional buffer window
that is greater than the maximum number of expected periods
in the forward returns calculations.
‘Prices’ must contain at least an entry for each timestamp/asset
combination in ‘factor’. This entry must be the asset price
at the time the asset factor value is computed and it will be
considered the buy price for that asset at that timestamp.
‘Prices’ must also contain entries for timestamps following each
timestamp/asset combination in ‘factor’, as many more timestamps
as the maximum value in ‘periods’. The asset price after ‘period’
timestamps will be considered the sell price for that asset when
computing ‘period’ forward returns.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">----------------------------------------------------</span>
            <span class="o">|</span> <span class="n">AAPL</span> <span class="o">|</span>  <span class="n">BA</span>  <span class="o">|</span>  <span class="n">CMG</span>  <span class="o">|</span>  <span class="n">DAL</span>  <span class="o">|</span>  <span class="n">LULU</span>  <span class="o">|</span>
<span class="o">----------------------------------------------------</span>
   <span class="n">Date</span>     <span class="o">|</span>      <span class="o">|</span>      <span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>
<span class="o">----------------------------------------------------</span>
<span class="mi">2014</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">01</span>  <span class="o">|</span><span class="mf">605.12</span><span class="o">|</span> <span class="mf">24.58</span><span class="o">|</span>  <span class="mf">11.72</span><span class="o">|</span> <span class="mf">54.43</span> <span class="o">|</span>  <span class="mf">37.14</span> <span class="o">|</span>
<span class="o">----------------------------------------------------</span>
<span class="mi">2014</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">02</span>  <span class="o">|</span><span class="mf">604.35</span><span class="o">|</span> <span class="mf">22.23</span><span class="o">|</span>  <span class="mf">12.21</span><span class="o">|</span> <span class="mf">52.78</span> <span class="o">|</span>  <span class="mf">33.63</span> <span class="o">|</span>
<span class="o">----------------------------------------------------</span>
<span class="mi">2014</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">03</span>  <span class="o">|</span><span class="mf">607.94</span><span class="o">|</span> <span class="mf">21.68</span><span class="o">|</span>  <span class="mf">14.36</span><span class="o">|</span> <span class="mf">53.94</span> <span class="o">|</span>  <span class="mf">29.37</span> <span class="o">|</span>
<span class="o">----------------------------------------------------</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>groupby</strong> : pd.Series - MultiIndex or dict</p>
<blockquote>
<div><p>Either A MultiIndex Series indexed by date and asset,
containing the period wise group codes for each asset, or
a dict of asset to group mappings. If a dict is passed,
it is assumed that group mappings are unchanged for the
entire time period of the passed factor data.</p>
</div></blockquote>
<p><strong>binning_by_group</strong> : bool</p>
<blockquote>
<div><p>If True, compute quantile buckets separately for each group.
This is useful when the factor values range vary considerably
across gorups so that it is wise to make the binning group relative.
You should probably enable this if the factor is intended
to be analyzed for a group neutral portfolio</p>
</div></blockquote>
<p><strong>quantiles</strong> : int or sequence[float]</p>
<blockquote>
<div><p>Number of equal-sized quantile buckets to use in factor bucketing.
Alternately sequence of quantiles, allowing non-equal-sized buckets
e.g. [0, .10, .5, .90, 1.] or [.05, .5, .95]
Only one of ‘quantiles’ or ‘bins’ can be not-None</p>
</div></blockquote>
<p><strong>bins</strong> : int or sequence[float]</p>
<blockquote>
<div><p>Number of equal-width (valuewise) bins to use in factor bucketing.
Alternately sequence of bin edges allowing for non-uniform bin width
e.g. [-4, -2, -0.5, 0, 10]
Chooses the buckets to be evenly spaced according to the values
themselves. Useful when the factor contains discrete values.
Only one of ‘quantiles’ or ‘bins’ can be not-None</p>
</div></blockquote>
<p><strong>periods</strong> : sequence[int]</p>
<blockquote>
<div><p>periods to compute forward returns on.</p>
</div></blockquote>
<p><strong>filter_zscore</strong> : int or float, optional</p>
<blockquote>
<div><p>Sets forward returns greater than X standard deviations
from the the mean to nan. Set it to ‘None’ to avoid filtering.
Caution: this outlier filtering incorporates lookahead bias.</p>
</div></blockquote>
<p><strong>groupby_labels</strong> : dict</p>
<blockquote>
<div><p>A dictionary keyed by group code with values corresponding
to the display name for each group.</p>
</div></blockquote>
<p><strong>max_loss</strong> : float, optional</p>
<blockquote>
<div><p>Maximum percentage (0.00 to 1.00) of factor data dropping allowed,
computed comparing the number of items in the input factor index and
the number of items in the output DataFrame index.
Factor data can be partially dropped due to being flawed itself
(e.g. NaNs), not having provided enough price data to compute
forward returns for all factor values, or because it is not possible
to perform binning.
Set max_loss=0 to avoid Exceptions suppression.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>merged_data</strong> : pd.DataFrame - MultiIndex</p>
<blockquote class="last">
<div><p>A MultiIndex Series indexed by date (level 0) and asset (level 1),
containing the values for a single alpha factor, forward returns for
each period, the factor quantile/bin that factor value belongs to, and
(optionally) the group the asset belongs to.
- forward returns column names follow  the format accepted by</p>
<blockquote>
<div><p>pd.Timedelta (e.g. ‘1D’, ‘30m’, ‘3h15m’, ‘1D1h’, etc)</p>
</div></blockquote>
<ul class="simple">
<li>‘date’ index freq property (merged_data.index.levels[0].freq) will be
set to Calendar day or Business day (pandas DateOffset) depending on
what was inferred from the input data. This is currently used only in
cumulative returns computation but it can be later set to any
pd.DateOffset (e.g. US trading calendar) to increase the accuracy
of the results</li>
</ul>
<dl class="docutils">
<dt>::</dt>
<dd><blockquote class="first">
<div><div class="line-block">
<div class="line">| 1D  | 5D  | 10D  <a href="#id1"><span class="problematic" id="id2">|</span></a>factor|group|factor_quantile</div>
</div>
</div></blockquote>
<blockquote>
<div><p>date   | asset |     |     |      |      |     |</p>
</div></blockquote>
<blockquote>
<div><div class="line-block">
<div class="line">AAPL  | 0.09|-0.01|-0.079|  0.5 |  G1 |      3</div>
</div>
<div class="line-block">
<div class="line">BA    | 0.02| 0.06| 0.020| -1.1 |  G2 |      5</div>
</div>
</div></blockquote>
<dl class="last docutils">
<dt>2014-01-01 | CMG   | 0.03| 0.09| 0.036|  1.7 |  G2 |      1</dt>
<dd><div class="first line-block">
<div class="line">DAL   <a href="#id3"><span class="problematic" id="id4">|-0.02|</span></a>-0.06|-0.029| -0.1 |  G3 |      5</div>
</div>
<div class="last line-block">
<div class="line">LULU  <a href="#id5"><span class="problematic" id="id6">|-0.03|</span></a> 0.05|-0.009|  2.7 |  G1 |      2</div>
</div>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.get_clean_factor_and_forward_returns_api_change_warning">
<code class="descclassname">alphalens.utils.</code><code class="descname">get_clean_factor_and_forward_returns_api_change_warning</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.get_clean_factor_and_forward_returns_api_change_warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator used to help API transition: maintain the function backward
compatible and warn the user about the API change.
Old API:</p>
<blockquote>
<div><dl class="docutils">
<dt>get_clean_factor_and_forward_returns(factor,</dt>
<dd>prices,
groupby=None,
by_group=False,
quantiles=5,
bins=None,
periods=(1, 5, 10),
filter_zscore=20,
groupby_labels=None,
max_loss=0.25)</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>New API:</dt>
<dd><dl class="first last docutils">
<dt>get_clean_factor_and_forward_returns(factor,</dt>
<dd>prices,
groupby=None,
binning_by_group=False,
quantiles=5,
bins=None,
periods=(1, 5, 10),
filter_zscore=20,
groupby_labels=None,
max_loss=0.25)</dd>
</dl>
</dd>
</dl>
<p>Eventually this function can be deleted</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.get_forward_returns_columns">
<code class="descclassname">alphalens.utils.</code><code class="descname">get_forward_returns_columns</code><span class="sig-paren">(</span><em>columns</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.get_forward_returns_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility that detects and returns the columns that are forward returns</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.non_unique_bin_edges_error">
<code class="descclassname">alphalens.utils.</code><code class="descname">non_unique_bin_edges_error</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.non_unique_bin_edges_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Give user a more informative error in case it is not possible
to properly calculate quantiles on the input dataframe (factor)</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.print_table">
<code class="descclassname">alphalens.utils.</code><code class="descname">print_table</code><span class="sig-paren">(</span><em>table</em>, <em>name=None</em>, <em>fmt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.print_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty print a pandas DataFrame.</p>
<p>Uses HTML output if running inside Jupyter Notebook, otherwise
formatted text output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>table</strong> : pd.Series or pd.DataFrame</p>
<blockquote>
<div><p>Table to pretty-print.</p>
</div></blockquote>
<p><strong>name</strong> : str, optional</p>
<blockquote>
<div><p>Table name to display in upper left corner.</p>
</div></blockquote>
<p><strong>fmt</strong> : str, optional</p>
<blockquote class="last">
<div><p>Formatter to use for displaying table elements.
E.g. ‘{0:.2f}%’ for displaying 100 as ‘100.00%’.
Restores original setting after displaying.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.quantize_factor">
<code class="descclassname">alphalens.utils.</code><code class="descname">quantize_factor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.quantize_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="alphalens.utils.rate_of_return">
<code class="descclassname">alphalens.utils.</code><code class="descname">rate_of_return</code><span class="sig-paren">(</span><em>period_ret</em>, <em>base_period</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.rate_of_return" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert returns to ‘one_period_len’ rate of returns: that is the value the
returns would have every ‘one_period_len’ if they had grown at a steady
rate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>period_ret: pd.DataFrame</strong></p>
<blockquote>
<div><p>DataFrame containing returns values with column headings representing
the return period.</p>
</div></blockquote>
<p><strong>base_period: string</strong></p>
<blockquote>
<div><p>The base period length used in the conversion
It must follow pandas.Timedelta constructor format (e.g. ‘1 days’,
‘1D’, ‘30m’, ‘3h’, ‘1D1h’, etc)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pd.DataFrame</p>
<blockquote class="last">
<div><p>DataFrame in same format as input but with ‘one_period_len’ rate of
returns values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.rethrow">
<code class="descclassname">alphalens.utils.</code><code class="descname">rethrow</code><span class="sig-paren">(</span><em>exception</em>, <em>additional_message</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.rethrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-raise the last exception that was active in the current scope
without losing the stacktrace but adding an additional message.
This is hacky because it has to be compatible with both python 2/3</p>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.std_conversion">
<code class="descclassname">alphalens.utils.</code><code class="descname">std_conversion</code><span class="sig-paren">(</span><em>period_std</em>, <em>base_period</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.std_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>one_period_len standard deviation (or standard error) approximation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>period_std: pd.DataFrame</strong></p>
<blockquote>
<div><p>DataFrame containing standard deviation or standard error values
with column headings representing the return period.</p>
</div></blockquote>
<p><strong>base_period: string</strong></p>
<blockquote>
<div><p>The base period length used in the conversion
It must follow pandas.Timedelta constructor format (e.g. ‘1 days’,
‘1D’, ‘30m’, ‘3h’, ‘1D1h’, etc)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pd.DataFrame</p>
<blockquote class="last">
<div><p>DataFrame in same format as input but with one-period
standard deviation/error values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="alphalens.utils.timedelta_to_string">
<code class="descclassname">alphalens.utils.</code><code class="descname">timedelta_to_string</code><span class="sig-paren">(</span><em>timedelta</em><span class="sig-paren">)</span><a class="headerlink" href="#alphalens.utils.timedelta_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility that converts a pandas.Timedelta to a string representation
compatible with pandas.Timedelta constructor format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>timedelta: pd.Timedelta</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">string</p>
<blockquote class="last">
<div><p>string representation of ‘timedelta’</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Quantopian, Inc..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.2.1+48.gad0be10',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>